{
	"Include bits/stdc++.h, ios_base, and namespace": {
		"prefix": "inc",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#define ll long long",
			"#define vll vector<long long>",
			"#define db double",
			"#define vi vector<int>",
			"#define vvi vector<vector<int>>",
			"#define pb push_back",
			"#define mp make_pair",
			"#define sorta(a) sort(a.begin(), a.end())",
			"#define sortd(a) sort(a.begin(), a.end(), greater<int>())",
			"#define vpll vector<pair<ll, ll>>",
			"#define forn(i,e) for(ll i = 0; i < e; i++)",
			"#define forsn(i,s,e) for(ll i = s; i < e; i++)",
			"#define rforn(i,s) for(ll i = s; i >= 0; i--)",
			"#define rforsn(i,s,e) for(ll i = s; i >= e; i--)",
			"#define pq priority_queue<ll>",
			"struct custom_hash {",
			"    static uint64_t splitmix64(uint64_t x) {",
			"        // http://xorshift.di.unimi.it/splitmix64.c",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			"#define umap unordered_map<ll, ll, custom_hash>",
			"#define uset unordered_set<ll,custom_hash>",
			"",
			"ll pow(ll base, ll exponent, ll modulus) {",
			"    ll result = 1;",
			"    base = base % modulus;",
			"    while (exponent > 0) {",
			"        if (exponent % 2 == 1) {",
			"            result = (result * base) % modulus;",
			"        }",
			"        exponent = exponent >> 1;",
			"        base = (base * base) % modulus;",
			"    }",
			"    return result;",
			"}",
			"",
			"// Print function without newline",
			"template <typename T>",
			"void prints_helper(const T &t)",
			"{",
			"    cout << t;",
			"}",
			"",
			"template <typename T, typename... Args>",
			"void prints_helper(const T &t, const Args &...args)",
			"{",
			"    cout << t;",
			"    prints_helper(args...);",
			"}",
			"",
			"template <typename... Args>",
			"void prints(const Args &...args)",
			"{",
			"    prints_helper(args...);",
			"}",
			"",
			"// Print function with newline",
			"",
			"template <typename T>",
			"void print_helper(const T &t)",
			"{",
			"    cout << t<<\" \";",
			"}",
			"",
			"template <typename T>",
			"void print_helper(const vector<T> &v)",
			"{",
			"    cout << \"[\";",
			"    for (auto it = v.begin(); it != v.end(); ++it)",
			"    {",
			"        if (it != v.begin())",
			"            cout << \", \";",
			"        cout << *it;",
			"    }",
			"    cout << \"]\";",
			"}",
			"",
			"template <typename T>",
			"void print_helper(const set<T> &s)",
			"{",
			"    cout << \"{\";",
			"    for (auto it = s.begin(); it != s.end(); ++it)",
			"    {",
			"        if (it != s.begin())",
			"            cout << \", \";",
			"        cout << *it;",
			"    }",
			"    cout << \"}\";",
			"}",
			"",
			"template <typename T>",
			"void print_helper(const unordered_set<T,custom_hash> &us)",
			"{",
			"    cout << \"{\";",
			"    for (auto it = us.begin(); it != us.end(); ++it)",
			"    {",
			"        if (it != us.begin())",
			"            cout << \", \";",
			"        cout << *it;",
			"    }",
			"    cout << \"}\";",
			"}",
			"",
			"template <typename K, typename V>",
			"void print_helper(const map<K, V> &m)",
			"{",
			"    cout << \"{\";",
			"    for (auto it = m.begin(); it != m.end(); ++it)",
			"    {",
			"        if (it != m.begin())",
			"            cout << \", \";",
			"        cout << it->first << \": \" << it->second;",
			"    }",
			"    cout << \"}\";",
			"}",
			"",
			"template <typename K, typename V>",
			"void print_helper(const unordered_map<K, V,custom_hash> &um)",
			"{",
			"    cout << \"{\";",
			"    for (auto it = um.begin(); it != um.end(); ++it)",
			"    {",
			"        if (it != um.begin())",
			"            cout << \", \";",
			"        cout << it->first << \": \" << it->second;",
			"    }",
			"    cout << \"}\";",
			"}",
			"",
			"template <typename T, typename... Args>",
			"void print_helper(const T &t, const Args &...args)",
			"{",
			"    print_helper(t);",
			"    print_helper(args...);",
			"}",
			"",
			"template <typename... Args>",
			"void print(const Args &...args)",
			"{",
			"    print_helper(args...);",
			"    cout << endl;",
			"}",
			"",
			"",
			"",
			"int main() {",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tcout.tie(NULL);",
			"\tint t;",
			"\tcin >> t;",
			"\twhile (t--) {",
			"\t\t$0",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "Include bits/stdc++.h, ios_base, and namespace with main()"
	},
	"Creating linked list": {
		"prefix": "ll",
		"body": [
			"#include <iostream>",
			"using namespace std;",
			"",
			"class Node {",
			"public:",
			"    int data;",
			"    Node *next;",
			"    Node(int data) {",
			"        this->data = data;",
			"        this->next = nullptr;",
			"    }",
			"};",
			"",
			"void insertAtHead(Node *&head, int data) {",
			"    Node *newNode = new Node(data);",
			"    newNode->next = head;",
			"    head = newNode;",
			"}",
			"",
			"void print(Node *&head) {",
			"    Node *temp = head;",
			"    while (temp != nullptr) {",
			"        cout << temp->data << ' ';",
			"        cout << temp << endl;",
			"        temp = temp->next;",
			"    }",
			"}",
			"",
			"void insertAtTail(Node *&tail, int data) {",
			"    Node *newNode = new Node(data);",
			"    tail->next = newNode;",
			"    tail = newNode;",
			"}"
		],
		"description": "Creates code for a basic linked list implementation in C++."
	},
	"Binary Tree": {
		"prefix": "bt",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"class Node {",
			"public:",
			"    int data;",
			"    Node *left = nullptr, *right = nullptr;",
			"    Node(int data) {",
			"        this->data = data;",
			"    }",
			"};",
			"",
			"void preOrder(Node *&root) {",
			"    if (root == nullptr)",
			"        return;",
			"    cout << root->data << ' ';",
			"    preOrder(root->left);",
			"    preOrder(root->right);",
			"}",
			"",
			"void inOrder(Node *&root) {",
			"    if (root == nullptr)",
			"        return;",
			"    inOrder(root->left);",
			"    cout << root->data << ' ';",
			"    inOrder(root->right);",
			"}",
			"",
			"void postOrder(Node *&root) {",
			"    if (root == nullptr)",
			"        return;",
			"    postOrder(root->left);",
			"    postOrder(root->right);",
			"    cout << root->data << ' ';",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    Node *root = new Node(1);",
			"    root->left = new Node(2);",
			"    root->right = new Node(3);",
			"    root->left->left = new Node(4);",
			"    root->left->right = new Node(5);",
			"    preOrder(root);",
			"    return 0;",
			"}"
		],
		"description": "Binary Tree Traversal: Pre-order, In-order, and Post-order"
	}
}